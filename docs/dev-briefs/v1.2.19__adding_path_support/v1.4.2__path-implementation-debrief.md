# Path Support Implementation Debrief

**version**: v1.4.2

## Summary

This document outlines the key implementation decisions made during the path support feature development that **differ from the original brief** (`v1_2_19__path-support__implementation-brief.md`). An LLM comparing the implemented code against the original brief should expect these intentional deviations.

---

## Key Decision Changes

### 1. Path Cardinality: 1:Many (NOT 1:1)

**Original Brief**: Specified unique paths with 1:1 relationship — each path maps to exactly one node/edge.

**Implementation Decision**: Changed to 1:many relationship, matching the existing `node_type` indexing pattern.

**Rationale**: 
- Real-world use cases (HTML DOM, JSON structures) frequently have multiple elements sharing the same path (e.g., multiple `<div>` elements at `html.body.div`)
- Aligns with how `nodes_by_type` already works in MGraph-DB
- More flexible — unique paths can still be enforced at the application layer if needed

**Code Impact**:
```python
# Original brief implied:
nodes_by_path: Dict[Node_Path, Node_Id]        # 1:1

# Actual implementation:
nodes_by_path: Dict[Node_Path, Set[Node_Id]]   # 1:many
edges_by_path: Dict[Edge_Path, Set[Edge_Id]]   # 1:many
```

---

### 2. Index Structure Changed

**Original Brief**: Simple dict mapping path → single ID.

**Implementation Decision**: Dict mapping path → Set of IDs.

**Code Impact**:
```python
# Index methods return Sets, not single values:
def get_nodes_by_path(self, node_path: Node_Path) -> Set[Node_Id]: ...
def get_edges_by_path(self, edge_path: Edge_Path) -> Set[Edge_Id]: ...
```

---

### 3. No Prefix Indexing

**Original Brief**: May have implied or included prefix-based path lookups (e.g., find all nodes under `html.body.*`).

**Implementation Decision**: No prefix indexing implemented. Only exact path matching.

**Rationale**:
- Prefix matching is an application-specific optimization
- Adds significant complexity to the core index
- Can be implemented at the domain/provider layer if needed
- Keeps the core implementation simple and focused

**What This Means**:
- `get_nodes_by_path(Node_Path("html.body"))` returns only nodes with exactly that path
- It does NOT return nodes with paths like `html.body.div` or `html.body.span`

---

### 4. Uses New ID Types from Recent Refactoring

**Context**: MGraph-DB recently refactored to use typed ID primitives.

**Implementation Decision**: Path implementation uses:
- `Node_Id` (not raw strings or UUIDs)
- `Edge_Id` (not raw strings or UUIDs)  
- `Graph_Id` (not raw strings or UUIDs)

**Note**: If the original brief was written before this refactoring, it may reference different ID handling.

---

### 5. Paths are Separate from Value Indexing

**Implementation Decision**: Path indexing is a completely separate system from the existing `values_index`.

**Structure**:
- `nodes_by_path` / `edges_by_path` live in `Schema__MGraph__Index__Data`
- They are peers to `nodes_by_type` / `edges_by_type`
- They do NOT interact with or depend on the value indexing system

---

## Schema Field Locations

The path fields were added to these schemas:

| Schema | Field Added | Type | Default |
|--------|-------------|------|---------|
| `Schema__MGraph__Node` | `node_path` | `Node_Path` | `None` |
| `Schema__MGraph__Edge` | `edge_path` | `Edge_Path` | `None` |
| `Schema__MGraph__Graph` | `graph_path` | `Graph_Path` | `None` |
| `Schema__MGraph__Index__Data` | `nodes_by_path` | `Dict[Node_Path, Set[Node_Id]]` | `{}` |
| `Schema__MGraph__Index__Data` | `edges_by_path` | `Dict[Edge_Path, Set[Edge_Id]]` | `{}` |

---

## API Summary

### MGraph__Edit Methods
```python
new_node(node_path: Node_Path = None, **kwargs)
new_edge(edge_path: Edge_Path = None, **kwargs)
new_value(..., node_path: Node_Path = None)
set_node_path(node_id: Node_Id, node_path: Node_Path) -> bool
set_edge_path(edge_id: Edge_Id, edge_path: Edge_Path) -> bool
```

### MGraph__Index Methods
```python
get_nodes_by_path(node_path: Node_Path) -> Set[Node_Id]
get_edges_by_path(edge_path: Edge_Path) -> Set[Edge_Id]
nodes_by_path() -> Dict[Node_Path, Set[Node_Id]]
edges_by_path() -> Dict[Edge_Path, Set[Edge_Id]]
```

---

## Backward Compatibility

All changes are backward compatible:
- Path fields default to `None`
- Existing graphs load without modification
- Code not using paths continues unchanged
- Type_Safe's default handling sets path fields appropriately when loading old data


-------- 

# Implementation Review: Path Support (v1.4.3)

Taking into account the original brief, the debrief document and the v1.4.3 source code, here's the implementation review:

---

### ✅ Fully Implemented (Core Features)

| Component | Status | Notes |
|-----------|--------|-------|
| **Safe_Str__Graph__Path** | ✅ | Implemented in `schemas/safe_str/` |
| **Path Type Aliases** | ✅ | `Edge_Path`, `Node_Path`, `Graph_Path` in `schemas/identifiers/` |
| **Schema__MGraph__Graph.graph_path** | ✅ | `graph_path : Graph_Path = None` |
| **Schema__MGraph__Node.node_path** | ✅ | `node_path : Node_Path = None` |
| **Schema__MGraph__Edge.edge_path** | ✅ | `edge_path : Edge_Path = None` |
| **Schema__MGraph__Index__Data** | ✅ | `nodes_by_path`, `edges_by_path` with `Set` semantics |
| **MGraph__Edit.new_node()** | ✅ | Accepts `node_path` parameter |
| **MGraph__Edit.new_edge()** | ✅ | Accepts `edge_path` parameter |
| **MGraph__Edit.new_value()** | ✅ | Accepts `node_path` parameter |
| **MGraph__Edit.set_node_path()** | ✅ | With index update logic |
| **MGraph__Edit.set_edge_path()** | ✅ | With index update logic |
| **MGraph__Index._index_node_path()** | ✅ | Adds to path index |
| **MGraph__Index._index_edge_path()** | ✅ | Adds to path index |
| **MGraph__Index._remove_node_path()** | ✅ | Removes from path index with cleanup |
| **MGraph__Index._remove_edge_path()** | ✅ | Removes from path index with cleanup |
| **MGraph__Index.get_nodes_by_path()** | ✅ | Returns `Set[Node_Id]` |
| **MGraph__Index.get_edges_by_path()** | ✅ | Returns `Set[Edge_Id]` |
| **MGraph__Index.nodes_by_path()** | ✅ | Raw accessor |
| **MGraph__Index.edges_by_path()** | ✅ | Raw accessor |
| **Index stats include paths** | ✅ | `stats()` method reports path statistics |

---

### ✅ Intentional Deviations (Per Debrief)

| Deviation | Brief | Implementation | Rationale |
|-----------|-------|----------------|-----------|
| **Cardinality** | 1:1 (unique paths) | 1:many (Set semantics) | Matches real-world DOM/JSON patterns |
| **Prefix indexing** | Implied | Not implemented | Application-layer concern, keeps core simple |
| **ID types** | May have referenced older types | Uses `Node_Id`, `Edge_Id`, `Graph_Id` | Aligns with recent refactoring |

---

### ✅ Implementation Quality Notes

**Good patterns observed:**

1. **Index cleanup on removal** - Both `_remove_node_path` and `_remove_edge_path` properly clean up empty sets:
```python
if not self.index_data.nodes_by_path[node_path]:  # Clean up empty sets
    del self.index_data.nodes_by_path[node_path]
```

2. **set_node_path/set_edge_path handle re-indexing** - They remove from old path index before adding to new:
```python
if old_path:                                    # Remove from old path index
    self.index()._remove_node_path(node.node.data)
node.node.data.node_path = node_path            # Update the node's path
if node_path:                                   # Add to new path index
    self.index()._index_node_path(node.node.data)
```

3. **Consistent with existing patterns** - Path indexing mirrors `nodes_by_type`/`edges_by_type` structure

---

### ❓ Unable to Verify (Not in Provided Code)

| Item | Status |
|------|--------|
| Unit tests for `Safe_Str__Graph__Path` | Not in snapshot |
| Integration tests for path indexing | Not in snapshot |
| Provider schema inheritance verification | Not in snapshot |

---

### Summary

| Category | Status |
|----------|--------|
| Core schema changes | ✅ Complete |
| Path indexing (1:many) | ✅ Complete |
| Edit operations | ✅ Complete |
| Index removal/cleanup | ✅ Complete |
| Prefix indexing | ✅ Intentionally omitted |
| Tests | ❓ Unknown |

**Verdict:** The implementation appears complete and consistent with the debrief's documented decisions. The 1:many design choice is well-justified for DOM/JSON use cases, and the code follows MGraph-DB's existing patterns. No gaps identified.