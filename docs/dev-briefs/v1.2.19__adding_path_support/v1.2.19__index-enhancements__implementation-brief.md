# MGraph-DB Index Enhancements Implementation Brief

## Executive Summary

This brief describes enhancements to MGraph-DB's `MGraph__Index` and `MGraph__Index__Values` classes to provide a more consistent, complete, and REST-friendly API. These changes add missing accessor methods, string-based query alternatives, and utility methods needed by service layers that cannot pass Python type objects.

---

## Motivation

### The Problem

When building a REST API service layer (MGraph-AI Service Graph) on top of MGraph-DB, several friction points emerged:

1. **Inconsistent access patterns** - Some index data requires direct `index_data` access while other data has accessor methods
2. **Type object requirements** - Methods like `get_nodes_by_type(node_type: Type)` require Python type objects, which REST clients cannot provide
3. **Missing utility methods** - No explicit `rebuild()` method; service attempted non-existent `mgraph.query().re_index()`
4. **Incomplete stats** - Stats method may not return all data needed for monitoring/debugging

### Design Principles

1. **Consistent API** - All index data accessible via methods, not direct `index_data` access
2. **Dual interfaces** - Type-based methods (for Python) alongside string-based methods (for REST)
3. **No breaking changes** - All existing methods remain; new methods are additions
4. **Clear naming** - String-based variants use `_by_type_name` suffix

---

## Implementation Specification

### Part 1: Missing Accessor Methods on MGraph__Index

#### File: `mgraph_db/mgraph/actions/MGraph__Index.py`

Add accessor methods for index_data fields that currently lack them:

```python
def edges_predicates(self) -> Dict[Obj_Id, Safe_Id]:
    """Get mapping of edge_id -> predicate for all edges with predicates."""
    return self.index_data.edges_predicates

def edges_by_predicate(self) -> Dict[Safe_Id, Set[Obj_Id]]:
    """Get mapping of predicate -> set of edge_ids."""
    return self.index_data.edges_by_predicate

def edges_by_incoming_label(self) -> Dict[Safe_Id, Set[Obj_Id]]:
    """Get mapping of incoming_label -> set of edge_ids."""
    return self.index_data.edges_by_incoming_label

def edges_by_outgoing_label(self) -> Dict[Safe_Id, Set[Obj_Id]]:
    """Get mapping of outgoing_label -> set of edge_ids."""
    return self.index_data.edges_by_outgoing_label
```

**Rationale:** Service code currently does `mgraph_index.index_data.edges_by_predicate`. All other major index structures have accessor methods (`nodes_by_type()`, `edges_by_type()`, etc.). These additions complete the pattern.

---

### Part 2: String-Based Type Query Methods

#### File: `mgraph_db/mgraph/actions/MGraph__Index.py`

Add methods that accept type names as strings:

```python
def get_nodes_by_type_name(self, type_name: str) -> Set[Obj_Id]:
    """Get all node IDs of a given type by type name string.
    
    Args:
        type_name: The type's __name__ (e.g., 'Schema__MGraph__Node', 'Domain__Node__Person')
    
    Returns:
        Set of node IDs matching the type name, or empty set if not found.
    """
    for node_type, node_ids in self.index_data.nodes_by_type.items():
        if self._type_to_name(node_type) == type_name:
            return node_ids
    return set()

def get_edges_by_type_name(self, type_name: str) -> Set[Obj_Id]:
    """Get all edge IDs of a given type by type name string.
    
    Args:
        type_name: The type's __name__ (e.g., 'Schema__MGraph__Edge', 'Domain__Edge__Contains')
    
    Returns:
        Set of edge IDs matching the type name, or empty set if not found.
    """
    for edge_type, edge_ids in self.index_data.edges_by_type.items():
        if self._type_to_name(edge_type) == type_name:
            return edge_ids
    return set()

def get_node_outgoing_edges_by_type_name(self, node_id: Obj_Id, type_name: str) -> Set[Obj_Id]:
    """Get outgoing edges from a node filtered by edge type name.
    
    Args:
        node_id: The source node ID
        type_name: The edge type's __name__
    
    Returns:
        Set of edge IDs, or empty set if node not found or no matching edges.
    """
    edges_by_type = self.index_data.nodes_to_outgoing_edges_by_type.get(node_id, {})
    for edge_type, edge_ids in edges_by_type.items():
        if self._type_to_name(edge_type) == type_name:
            return edge_ids
    return set()

def get_node_incoming_edges_by_type_name(self, node_id: Obj_Id, type_name: str) -> Set[Obj_Id]:
    """Get incoming edges to a node filtered by edge type name.
    
    Args:
        node_id: The target node ID
        type_name: The edge type's __name__
    
    Returns:
        Set of edge IDs, or empty set if node not found or no matching edges.
    """
    edges_by_type = self.index_data.nodes_to_incoming_edges_by_type.get(node_id, {})
    for edge_type, edge_ids in edges_by_type.items():
        if self._type_to_name(edge_type) == type_name:
            return edge_ids
    return set()

def _type_to_name(self, t) -> str:
    """Convert a type to its string name.
    
    Handles both actual type objects and string representations.
    """
    if t is None:
        return 'None'
    if isinstance(t, type):
        return t.__name__
    return str(t)
```

**Note on performance:** These methods iterate over type keys to find matches. For graphs with many types, this is O(n) where n = number of distinct types. In practice, n is small (typically < 50 types). If performance becomes an issue, a reverse lookup dict `type_name -> type` could be added to index_data.

---

### Part 3: Rebuild/Re-Index Methods

#### File: `mgraph_db/mgraph/actions/MGraph__Index.py`

Add explicit rebuild method:

```python
def rebuild(self) -> 'MGraph__Index':
    """Force complete rebuild of index from the graph.
    
    Creates a fresh index by re-scanning all nodes and edges.
    Useful after bulk modifications or to ensure index consistency.
    
    Returns:
        New MGraph__Index instance with fresh index data.
    """
    return MGraph__Index.from_graph(self.graph)
```

#### File: `mgraph_db/mgraph/MGraph.py` (or equivalent facade class)

Add convenience method on main MGraph facade:

```python
def re_index(self) -> MGraph__Index:
    """Force rebuild of graph index and return it.
    
    Discards current cached index and builds fresh from graph data.
    
    Returns:
        Fresh MGraph__Index instance.
    """
    self._index = MGraph__Index.from_graph(self.graph)
    return self._index
```

**Note:** Verify the exact location - this should be on whatever class the service calls `mgraph.index()` on. The service code uses:
```python
mgraph, resolved_ref = self.graph_service.resolve_graph_ref(graph_ref)
mgraph_index = mgraph.index()
```

---

### Part 4: Predicate Methods - Flexible Parameter Types

#### File: `mgraph_db/mgraph/actions/MGraph__Index.py`

Ensure predicate methods accept both `Safe_Id` and plain strings:

```python
def get_edges_by_predicate(self, predicate) -> Set[Obj_Id]:
    """Get all edges with a given predicate.
    
    Args:
        predicate: Predicate identifier (Safe_Id, Safe_Str__Id, or str)
    
    Returns:
        Set of edge IDs with this predicate.
    """
    predicate_str = str(predicate)
    return self.index_data.edges_by_predicate.get(predicate_str, set())

def get_node_outgoing_edges_by_predicate(self, node_id: Obj_Id, predicate) -> Set[Obj_Id]:
    """Get outgoing edges from a node with a given predicate.
    
    Args:
        node_id: The source node ID
        predicate: Predicate identifier (Safe_Id, Safe_Str__Id, or str)
    
    Returns:
        Set of edge IDs.
    """
    predicate_str = str(predicate)
    # Implementation depends on current index structure
    # If edges_by_predicate exists, filter by from_node
    all_predicate_edges = self.index_data.edges_by_predicate.get(predicate_str, set())
    outgoing_edges = self.index_data.nodes_to_outgoing_edges.get(node_id, set())
    return all_predicate_edges & outgoing_edges

def get_node_incoming_edges_by_predicate(self, node_id: Obj_Id, predicate) -> Set[Obj_Id]:
    """Get incoming edges to a node with a given predicate.
    
    Args:
        node_id: The target node ID
        predicate: Predicate identifier (Safe_Id, Safe_Str__Id, or str)
    
    Returns:
        Set of edge IDs.
    """
    predicate_str = str(predicate)
    all_predicate_edges = self.index_data.edges_by_predicate.get(predicate_str, set())
    incoming_edges = self.index_data.nodes_to_incoming_edges.get(node_id, set())
    return all_predicate_edges & incoming_edges

def get_nodes_by_predicate(self, from_node_id: Obj_Id, predicate) -> Set[Obj_Id]:
    """Get target nodes reachable from a node via a predicate.
    
    This is a convenience method for: from_node --[predicate]--> target_nodes
    
    Args:
        from_node_id: The source node ID
        predicate: Predicate identifier (Safe_Id, Safe_Str__Id, or str)
    
    Returns:
        Set of target node IDs.
    """
    edge_ids = self.get_node_outgoing_edges_by_predicate(from_node_id, predicate)
    target_nodes = set()
    for edge_id in edge_ids:
        edge_nodes = self.index_data.edges_to_nodes.get(edge_id)
        if edge_nodes:
            _, to_node = edge_nodes
            target_nodes.add(to_node)
    return target_nodes
```

**Type signature note:** Using bare `predicate` without type annotation allows any stringifiable type. Alternatively, use `predicate: str | Safe_Id` with `from __future__ import annotations` or `Union[str, Safe_Id]`.

---

### Part 5: Value Index String-Based Methods

#### File: `mgraph_db/mgraph/actions/MGraph__Index__Values.py`

Add string-based type lookup:

```python
# Type name to Python type mapping
VALUE_TYPE_MAP = {
    'str'    : str   ,
    'string' : str   ,
    'int'    : int   ,
    'integer': int   ,
    'float'  : float ,
    'bool'   : bool  ,
    'boolean': bool  ,
}

def get_node_id_by_value_and_type_name(self,
                                        value_type_name: str,
                                        value,
                                        key: str = '',
                                        node_type_name: str = None
                                       ) -> Optional[Obj_Id]:
    """Look up a value node by value with type specified as string.
    
    Args:
        value_type_name: Type name ('str', 'int', 'float', 'bool')
        value: The value to look up (will be converted to appropriate type)
        key: Optional key for value uniqueness
        node_type_name: Optional node type filter (not commonly used)
    
    Returns:
        Node ID if found, None otherwise.
    """
    value_type = VALUE_TYPE_MAP.get(value_type_name.lower(), str)
    
    # Convert value to appropriate type
    typed_value = self._convert_value(value, value_type)
    
    return self.get_node_id_by_value(
        value_type = value_type  ,
        value      = typed_value ,
        key        = key         ,
        node_type  = None        )  # node_type filtering requires type object

def _convert_value(self, value, target_type: type):
    """Convert a value to the target type.
    
    Handles string inputs from REST clients.
    """
    if target_type == str:
        return str(value)
    if target_type == int:
        return int(value)
    if target_type == float:
        return float(value)
    if target_type == bool:
        if isinstance(value, bool):
            return value
        if isinstance(value, str):
            return value.lower() in ('true', '1', 'yes')
        return bool(value)
    return value
```

---

### Part 6: Enhanced Stats Method

#### File: `mgraph_db/mgraph/actions/MGraph__Index.py`

Update or add comprehensive stats method:

```python
def stats(self) -> Dict:
    """Get comprehensive index statistics.
    
    Returns a dictionary with counts and breakdowns useful for
    monitoring, debugging, and service layer responses.
    """
    # Node stats
    nodes_by_type_counts = {
        self._type_to_name(t): len(ids) 
        for t, ids in self.index_data.nodes_by_type.items()
    }
    total_nodes = sum(nodes_by_type_counts.values())
    
    # Edge stats
    edges_by_type_counts = {
        self._type_to_name(t): len(ids) 
        for t, ids in self.index_data.edges_by_type.items()
    }
    total_edges = sum(edges_by_type_counts.values())
    
    # Predicate stats
    edges_by_predicate_counts = {
        str(p): len(ids) 
        for p, ids in self.index_data.edges_by_predicate.items()
    }
    
    # Label stats
    edges_by_incoming_label_counts = {
        str(l): len(ids) 
        for l, ids in self.index_data.edges_by_incoming_label.items()
    }
    edges_by_outgoing_label_counts = {
        str(l): len(ids) 
        for l, ids in self.index_data.edges_by_outgoing_label.items()
    }
    
    # Value index stats
    values_stats = {}
    if self.values_index:
        vi = self.values_index.index_data
        values_by_type_counts = {
            self._type_to_name(t): len(hashes) 
            for t, hashes in vi.values_by_type.items()
        }
        values_stats = {
            'total_value_nodes'      : len(vi.hash_to_node)       ,
            'value_types_count'      : len(values_by_type_counts) ,
            'values_by_type_counts'  : values_by_type_counts      ,
        }
    
    # Path stats (if path support is implemented)
    path_stats = {}
    if hasattr(self.index_data, 'nodes_by_path'):
        path_stats = {
            'nodes_with_paths' : len(self.index_data.nodes_by_path) ,
            'edges_with_paths' : len(self.index_data.edges_by_path) ,
        }
    
    return {
        # Node statistics
        'total_nodes'                    : total_nodes                    ,
        'node_types_count'               : len(nodes_by_type_counts)      ,
        'nodes_by_type_counts'           : nodes_by_type_counts           ,
        
        # Edge statistics  
        'total_edges'                    : total_edges                    ,
        'edge_types_count'               : len(edges_by_type_counts)      ,
        'edges_by_type_counts'           : edges_by_type_counts           ,
        
        # Predicate statistics
        'total_predicates'               : len(edges_by_predicate_counts) ,
        'edges_by_predicate_counts'      : edges_by_predicate_counts      ,
        
        # Label statistics
        'total_incoming_labels'          : len(edges_by_incoming_label_counts),
        'edges_by_incoming_label_counts' : edges_by_incoming_label_counts ,
        'total_outgoing_labels'          : len(edges_by_outgoing_label_counts),
        'edges_by_outgoing_label_counts' : edges_by_outgoing_label_counts ,
        
        # Value statistics
        **values_stats                                                    ,
        
        # Path statistics  
        **path_stats                                                      ,
    }
```

---

## Backward Compatibility

All changes are **additive**:

| Change | Impact |
|--------|--------|
| New accessor methods | No impact - existing direct `index_data` access still works |
| String-based query methods | No impact - existing type-based methods unchanged |
| `rebuild()` method | No impact - new method |
| `re_index()` on facade | No impact - new method |
| Flexible predicate params | No impact - existing calls with `Safe_Id` still work |
| Value index string methods | No impact - existing type-based methods unchanged |
| Enhanced `stats()` | Verify existing callers handle additional keys gracefully |

---

## Testing Requirements

### Unit Tests for New Accessor Methods

#### File: `tests/unit/mgraph/actions/test_MGraph__Index__accessors.py`

```python
def test_edges_predicates_accessor():
    """Test edges_predicates() returns same as index_data.edges_predicates."""
    mgraph = create_test_graph_with_predicates()
    index = mgraph.index()
    
    assert index.edges_predicates() is index.index_data.edges_predicates
    assert len(index.edges_predicates()) > 0

def test_edges_by_predicate_accessor():
    """Test edges_by_predicate() accessor method."""
    mgraph = create_test_graph_with_predicates()
    index = mgraph.index()
    
    assert index.edges_by_predicate() is index.index_data.edges_by_predicate

def test_edges_by_incoming_label_accessor():
    """Test edges_by_incoming_label() accessor method."""
    mgraph = create_test_graph_with_labels()
    index = mgraph.index()
    
    assert index.edges_by_incoming_label() is index.index_data.edges_by_incoming_label

def test_edges_by_outgoing_label_accessor():
    """Test edges_by_outgoing_label() accessor method."""
    mgraph = create_test_graph_with_labels()
    index = mgraph.index()
    
    assert index.edges_by_outgoing_label() is index.index_data.edges_by_outgoing_label
```

### Unit Tests for String-Based Methods

#### File: `tests/unit/mgraph/actions/test_MGraph__Index__string_methods.py`

```python
def test_get_nodes_by_type_name():
    """Test node lookup by type name string."""
    mgraph = MGraph__Graph()
    node1 = mgraph.edit().new_node(node_type=Schema__MGraph__Node)
    node2 = mgraph.edit().new_node(node_type=Schema__MGraph__Node)
    
    index = mgraph.index()
    
    # Lookup by string name
    found = index.get_nodes_by_type_name('Schema__MGraph__Node')
    assert node1.node_id in found
    assert node2.node_id in found
    
    # Non-existent type returns empty set
    assert index.get_nodes_by_type_name('NonExistent__Type') == set()

def test_get_edges_by_type_name():
    """Test edge lookup by type name string."""
    mgraph = MGraph__Graph()
    node1 = mgraph.edit().new_node()
    node2 = mgraph.edit().new_node()
    edge = mgraph.edit().new_edge(node1.node_id, node2.node_id)
    
    index = mgraph.index()
    
    type_name = type(edge).__name__
    found = index.get_edges_by_type_name(type_name)
    assert edge.edge_id in found

def test_get_node_outgoing_edges_by_type_name():
    """Test outgoing edge lookup by type name."""
    mgraph = MGraph__Graph()
    node1 = mgraph.edit().new_node()
    node2 = mgraph.edit().new_node()
    node3 = mgraph.edit().new_node()
    edge1 = mgraph.edit().new_edge(node1.node_id, node2.node_id)
    edge2 = mgraph.edit().new_edge(node1.node_id, node3.node_id)
    
    index = mgraph.index()
    type_name = type(edge1).__name__
    
    found = index.get_node_outgoing_edges_by_type_name(node1.node_id, type_name)
    assert edge1.edge_id in found
    assert edge2.edge_id in found

def test_get_node_incoming_edges_by_type_name():
    """Test incoming edge lookup by type name."""
    mgraph = MGraph__Graph()
    node1 = mgraph.edit().new_node()
    node2 = mgraph.edit().new_node()
    edge = mgraph.edit().new_edge(node1.node_id, node2.node_id)
    
    index = mgraph.index()
    type_name = type(edge).__name__
    
    found = index.get_node_incoming_edges_by_type_name(node2.node_id, type_name)
    assert edge.edge_id in found

def test_type_to_name_helper():
    """Test _type_to_name handles various inputs."""
    index = MGraph__Index()
    
    assert index._type_to_name(str) == 'str'
    assert index._type_to_name(Schema__MGraph__Node) == 'Schema__MGraph__Node'
    assert index._type_to_name(None) == 'None'
    assert index._type_to_name('already_string') == 'already_string'
```

### Unit Tests for Rebuild Methods

#### File: `tests/unit/mgraph/actions/test_MGraph__Index__rebuild.py`

```python
def test_index_rebuild():
    """Test rebuild() creates fresh index."""
    mgraph = MGraph__Graph()
    node1 = mgraph.edit().new_node()
    
    index1 = mgraph.index()
    assert node1.node_id in index1.get_node_id_outgoing_edges(node1.node_id) or True  # Just verify works
    
    # Add more nodes
    node2 = mgraph.edit().new_node()
    
    # Rebuild
    index2 = index1.rebuild()
    
    # Fresh index should be different object
    assert index2 is not index1
    
    # Both nodes should be in rebuilt index
    all_nodes = set()
    for node_ids in index2.nodes_by_type().values():
        all_nodes.update(node_ids)
    assert node1.node_id in all_nodes
    assert node2.node_id in all_nodes

def test_mgraph_re_index():
    """Test re_index() on MGraph facade."""
    mgraph = MGraph__Graph()
    node1 = mgraph.edit().new_node()
    
    index1 = mgraph.index()
    
    node2 = mgraph.edit().new_node()
    
    # Re-index via facade
    index2 = mgraph.re_index()
    
    # Should be same object as subsequent index() calls
    assert mgraph.index() is index2
```

### Unit Tests for Predicate Methods

#### File: `tests/unit/mgraph/actions/test_MGraph__Index__predicates.py`

```python
def test_get_edges_by_predicate_with_string():
    """Test predicate lookup accepts plain string."""
    mgraph = create_graph_with_predicate_edges()
    index = mgraph.index()
    
    # Should work with plain string
    edges = index.get_edges_by_predicate("has_name")
    assert len(edges) > 0

def test_get_edges_by_predicate_with_safe_id():
    """Test predicate lookup accepts Safe_Id."""
    mgraph = create_graph_with_predicate_edges()
    index = mgraph.index()
    
    # Should work with Safe_Id
    edges = index.get_edges_by_predicate(Safe_Id("has_name"))
    assert len(edges) > 0

def test_get_nodes_by_predicate():
    """Test semantic traversal via predicate."""
    mgraph = MGraph__Graph()
    person = mgraph.edit().new_node()
    name_value = mgraph.edit().new_node()
    edge = mgraph.edit().new_edge(person.node_id, name_value.node_id)
    # Set predicate on edge (implementation-dependent)
    
    index = mgraph.index()
    
    # Get nodes connected via "has_name" predicate
    targets = index.get_nodes_by_predicate(person.node_id, "has_name")
    # Verify name_value is in targets (if predicate was set)
```

### Unit Tests for Value Index String Methods

#### File: `tests/unit/mgraph/actions/test_MGraph__Index__Values__string_methods.py`

```python
def test_get_node_id_by_value_and_type_name_str():
    """Test value lookup with type as string."""
    mgraph = create_graph_with_value_nodes()
    index = mgraph.index()
    values_index = index.values_index
    
    # Lookup string value
    node_id = values_index.get_node_id_by_value_and_type_name(
        value_type_name = 'str',
        value           = 'test_value',
        key             = ''
    )
    assert node_id is not None

def test_get_node_id_by_value_and_type_name_int():
    """Test integer value lookup with type as string."""
    mgraph = create_graph_with_int_value_nodes()
    index = mgraph.index()
    values_index = index.values_index
    
    # Lookup with string "42" converted to int
    node_id = values_index.get_node_id_by_value_and_type_name(
        value_type_name = 'int',
        value           = '42',  # String input
        key             = ''
    )
    assert node_id is not None

def test_convert_value_bool():
    """Test boolean value conversion."""
    values_index = MGraph__Index__Values()
    
    assert values_index._convert_value('true', bool) == True
    assert values_index._convert_value('True', bool) == True
    assert values_index._convert_value('1', bool) == True
    assert values_index._convert_value('yes', bool) == True
    assert values_index._convert_value('false', bool) == False
    assert values_index._convert_value('0', bool) == False
    assert values_index._convert_value('no', bool) == False
```

### Unit Tests for Stats

#### File: `tests/unit/mgraph/actions/test_MGraph__Index__stats.py`

```python
def test_stats_comprehensive():
    """Test stats() returns all expected fields."""
    mgraph = create_comprehensive_test_graph()
    index = mgraph.index()
    
    stats = index.stats()
    
    # Required fields
    assert 'total_nodes' in stats
    assert 'node_types_count' in stats
    assert 'nodes_by_type_counts' in stats
    assert 'total_edges' in stats
    assert 'edge_types_count' in stats
    assert 'edges_by_type_counts' in stats
    assert 'total_predicates' in stats
    assert 'edges_by_predicate_counts' in stats
    
    # Type consistency
    assert isinstance(stats['total_nodes'], int)
    assert isinstance(stats['nodes_by_type_counts'], dict)
    
    # Values should be non-negative
    assert stats['total_nodes'] >= 0
    assert stats['total_edges'] >= 0

def test_stats_type_names_are_strings():
    """Test that stats uses string type names, not type objects."""
    mgraph = MGraph__Graph()
    mgraph.edit().new_node(node_type=Schema__MGraph__Node)
    
    index = mgraph.index()
    stats = index.stats()
    
    # Keys should be strings
    for type_name in stats['nodes_by_type_counts'].keys():
        assert isinstance(type_name, str)
        assert not isinstance(type_name, type)
```

---

## File Summary

### Files to Modify

| File | Changes |
|------|---------|
| `mgraph_db/mgraph/actions/MGraph__Index.py` | Add accessor methods, string-based query methods, rebuild(), flexible predicate params, enhanced stats() |
| `mgraph_db/mgraph/actions/MGraph__Index__Values.py` | Add get_node_id_by_value_and_type_name(), _convert_value() |
| `mgraph_db/mgraph/MGraph.py` (or facade) | Add re_index() convenience method |

### New Test Files

| File | Purpose |
|------|---------|
| `tests/unit/mgraph/actions/test_MGraph__Index__accessors.py` | Test new accessor methods |
| `tests/unit/mgraph/actions/test_MGraph__Index__string_methods.py` | Test string-based type queries |
| `tests/unit/mgraph/actions/test_MGraph__Index__rebuild.py` | Test rebuild functionality |
| `tests/unit/mgraph/actions/test_MGraph__Index__predicates.py` | Test predicate method flexibility |
| `tests/unit/mgraph/actions/test_MGraph__Index__Values__string_methods.py` | Test value index string methods |
| `tests/unit/mgraph/actions/test_MGraph__Index__stats.py` | Test enhanced stats |

---

## Implementation Order

1. **Add `_type_to_name()` helper** - Used by multiple methods
2. **Add accessor methods** - Simple additions, no dependencies
3. **Add string-based query methods** - Depend on `_type_to_name()`
4. **Add `rebuild()` method** - Simple addition
5. **Add `re_index()` to facade** - Depends on understanding facade structure
6. **Update predicate methods** - Ensure string params work
7. **Add value index string methods** - Including `_convert_value()`
8. **Enhance `stats()`** - Comprehensive update
9. **Add all tests** - Verify everything works
10. **Run existing tests** - Ensure no regressions

---

## Relationship to Path Support Brief

This brief is **independent but complementary** to the Path Support Implementation Brief:

- **Path Support Brief**: Adds `node_path`, `edge_path`, `graph_path` fields and path-based indexes
- **This Brief**: Enhances existing index API for REST compatibility

If implementing both:
1. Implement this brief first (enhances existing structures)
2. Implement path support second (adds new structures)
3. The enhanced `stats()` in this brief includes path stats conditionally

The `stats()` method in this brief already includes:
```python
if hasattr(self.index_data, 'nodes_by_path'):
    path_stats = {
        'nodes_with_paths': len(self.index_data.nodes_by_path),
        'edges_with_paths': len(self.index_data.edges_by_path),
    }
```

This ensures forward compatibility with path support.

---

## Notes for Implementation

1. **Import statements**: Follow existing codebase patterns
2. **Method ordering**: Place new methods near related existing methods
3. **Docstrings**: Include clear Args/Returns documentation
4. **Type hints**: Use `Optional`, `Set`, `Dict` from typing module consistently
5. **Existing tests**: Run full test suite after each modification
6. **Performance**: String-based type lookups are O(n) on type count - acceptable for typical graphs
