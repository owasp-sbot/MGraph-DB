# MGraph-DB Path Support Implementation Brief

## Executive Summary

This brief describes the addition of optional `path` fields to MGraph-DB's core schema objects (`Schema__MGraph__Graph`, `Schema__MGraph__Node`, `Schema__MGraph__Edge`). These paths provide a REST-friendly string-based identifier system that coexists with the existing Python `type` fields, enabling structural/positional identification of graph elements without requiring Python type resolution.

---

## Motivation

### The Problem

MGraph-DB uses Python `Type` objects for node and edge classification:

```python
node_type : Type['Schema__MGraph__Node']
edge_type : Type['Schema__MGraph__Edge']
```

This works excellently for local Python usage where OSBot-Utils can round-trip types via serialization. However, when exposing MGraph-DB through a REST API (MGraph-AI Service Graph), clients cannot provide Python type objects - they send strings.

### Use Cases for Paths

Paths serve as structural/semantic identifiers, particularly valuable for:

1. **Document graphs** (HTML, XML):
   - `html.body.div.p[1]`
   - `page.article:html.body.section.article[1]`

2. **Hierarchical data**:
   - `config.database.connection.timeout`
   - `user.preferences.theme`

3. **Indexed positions**:
   - `table.row[5].cell[3]`
   - `list.item[0]`

4. **Namespaced references**:
   - `node.path:html.body.div.p`
   - `source:target.relationship`

5. **REST API queries**: Clients can query by path string without needing Python type resolution.

### Design Decision

Rather than creating parallel schema hierarchies for the REST service layer, we add optional path fields directly to MGraph-DB core schemas. This:

- Maintains single source of truth
- Ensures backward compatibility (existing graphs load with `path = None`)
- Allows coexistence of type-based and path-based identification
- Enables index support for path-based queries

---

## Implementation Specification

### Part 1: New Primitive Type

#### File: `mgraph_db/mgraph/schemas/primitives/Safe_Str__Graph__Path.py`

Create a new Safe_Str primitive for graph paths:

```python
import re
from osbot_utils.type_safe.primitives.core.Safe_Str import Safe_Str

SAFE_STR__GRAPH__PATH__REGEX      = re.compile(r'[^a-zA-Z0-9_\-\.\:\[\]]')
SAFE_STR__GRAPH__PATH__MAX_LENGTH = 512

class Safe_Str__Graph__Path(Safe_Str):
    """Safe string for graph element paths.
    
    Allows: alphanumerics, underscores, hyphens, dots, colons, square brackets.
    
    Examples:
        - html.body.div.p[1]
        - node.path:html.body.section
        - config.database.timeout
        - Domain__Node__Person (also valid - superset of Safe_Str__Id)
    """
    regex           = SAFE_STR__GRAPH__PATH__REGEX
    max_length      = SAFE_STR__GRAPH__PATH__MAX_LENGTH
    allow_empty     = True
    trim_whitespace = True
```

**Character allowances:**
| Character | Purpose |
|-----------|---------|
| `a-zA-Z0-9` | Base identifiers |
| `_` | Word separation (Python style) |
| `-` | Word separation (kebab style) |
| `.` | Hierarchy separator |
| `:` | Namespace separator |
| `[]` | Index notation |

**Max length rationale:** 512 characters accommodates deep hierarchies like `page.content.article[1].section[2].paragraph[3].sentence[1].word[5]` while preventing unbounded strings.

---

### Part 2: Path Type Aliases

#### File: `mgraph_db/mgraph/schemas/primitives/Graph_Path.py`

```python
from mgraph_db.mgraph.schemas.primitives.Safe_Str__Graph__Path import Safe_Str__Graph__Path

class Graph_Path(Safe_Str__Graph__Path):
    """Path identifier for a graph."""
    pass
```

#### File: `mgraph_db/mgraph/schemas/primitives/Node_Path.py`

```python
from mgraph_db.mgraph.schemas.primitives.Safe_Str__Graph__Path import Safe_Str__Graph__Path

class Node_Path(Safe_Str__Graph__Path):
    """Path identifier for a node within a graph."""
    pass
```

#### File: `mgraph_db/mgraph/schemas/primitives/Edge_Path.py`

```python
from mgraph_db.mgraph.schemas.primitives.Safe_Str__Graph__Path import Safe_Str__Graph__Path

class Edge_Path(Safe_Str__Graph__Path):
    """Path identifier for an edge within a graph."""
    pass
```

**Why separate classes?** Type safety - prevents accidentally passing a `Node_Path` where `Edge_Path` is expected, even though underlying validation is identical.

---

### Part 3: Core Schema Modifications

#### File: `mgraph_db/mgraph/schemas/Schema__MGraph__Graph.py`

Add `graph_path` field:

```python
from typing                                                         import Dict, Type
from mgraph_db.mgraph.schemas.Schema__MGraph__Types                 import Schema__MGraph__Types
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge                  import Schema__MGraph__Edge
from mgraph_db.mgraph.schemas.Schema__MGraph__Graph__Data           import Schema__MGraph__Graph__Data
from mgraph_db.mgraph.schemas.Schema__MGraph__Node                  import Schema__MGraph__Node
from mgraph_db.mgraph.schemas.primitives.Graph_Path                 import Graph_Path
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id    import Obj_Id
from osbot_utils.type_safe.Type_Safe                                import Type_Safe

class Schema__MGraph__Graph(Type_Safe):
    edges        : Dict[Obj_Id, Schema__MGraph__Edge]
    graph_data   : Schema__MGraph__Graph__Data
    graph_id     : Obj_Id
    graph_path   : Graph_Path                       = None          # NEW: Optional path identifier
    graph_type   : Type['Schema__MGraph__Graph']
    nodes        : Dict[Obj_Id, Schema__MGraph__Node]
    schema_types : Schema__MGraph__Types
```

#### File: `mgraph_db/mgraph/schemas/Schema__MGraph__Node.py`

Add `node_path` field:

```python
from typing                                                         import Type
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id    import Obj_Id
from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Data            import Schema__MGraph__Node__Data
from mgraph_db.mgraph.schemas.primitives.Node_Path                  import Node_Path
from osbot_utils.type_safe.Type_Safe                                import Type_Safe

class Schema__MGraph__Node(Type_Safe):
    node_data : Schema__MGraph__Node__Data
    node_id   : Obj_Id
    node_path : Node_Path                           = None          # NEW: Optional path identifier
    node_type : Type['Schema__MGraph__Node']
```

#### File: `mgraph_db/mgraph/schemas/Schema__MGraph__Edge.py`

Add `edge_path` field:

```python
from typing                                                         import Type
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id    import Obj_Id
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge__Data            import Schema__MGraph__Edge__Data
from mgraph_db.mgraph.schemas.primitives.Edge_Path                  import Edge_Path
from osbot_utils.type_safe.Type_Safe                                import Type_Safe

class Schema__MGraph__Edge(Type_Safe):
    edge_data      : Schema__MGraph__Edge__Data
    edge_id        : Obj_Id
    edge_path      : Edge_Path                      = None          # NEW: Optional path identifier
    edge_type      : Type['Schema__MGraph__Edge']
    from_node_id   : Obj_Id
    to_node_id     : Obj_Id
```

---

### Part 4: Index Support for Paths

#### File: `mgraph_db/mgraph/actions/MGraph__Index__Data.py`

Add path-based index dictionaries:

```python
# Add to existing index_data fields:

# Path-based indexes (only populated when paths are set)
nodes_by_path           : Dict[str, Obj_Id]                     # path -> node_id (paths should be unique)
edges_by_path           : Dict[str, Obj_Id]                     # path -> edge_id (paths should be unique)
nodes_by_path_prefix    : Dict[str, Set[Obj_Id]]                # path_prefix -> set of node_ids
edges_by_path_prefix    : Dict[str, Set[Obj_Id]]                # path_prefix -> set of edge_ids
```

**Index semantics:**
- `nodes_by_path`: Direct lookup - assumes paths are unique within a graph
- `nodes_by_path_prefix`: Hierarchical lookup - find all nodes under `html.body.*`

#### File: `mgraph_db/mgraph/actions/MGraph__Index.py`

Add indexing logic for paths during index building:

```python
def _index_node_path(self, node: Schema__MGraph__Node) -> None:
    """Index a node's path if present."""
    if node.node_path:
        path_str = str(node.node_path)
        self.index_data.nodes_by_path[path_str] = node.node_id
        
        # Index path prefixes for hierarchical queries
        self._index_path_prefixes(path_str, node.node_id, self.index_data.nodes_by_path_prefix)

def _index_edge_path(self, edge: Schema__MGraph__Edge) -> None:
    """Index an edge's path if present."""
    if edge.edge_path:
        path_str = str(edge.edge_path)
        self.index_data.edges_by_path[path_str] = edge.edge_id
        
        # Index path prefixes for hierarchical queries
        self._index_path_prefixes(path_str, edge.edge_id, self.index_data.edges_by_path_prefix)

def _index_path_prefixes(self, path: str, obj_id: Obj_Id, prefix_index: Dict[str, Set[Obj_Id]]) -> None:
    """Index all prefixes of a path for hierarchical queries.
    
    For path 'html.body.div.p', indexes:
        - 'html' -> {obj_id}
        - 'html.body' -> {obj_id}
        - 'html.body.div' -> {obj_id}
        - 'html.body.div.p' -> {obj_id}
    """
    parts = path.replace('[', '.').replace(']', '').replace(':', '.').split('.')
    for i in range(1, len(parts) + 1):
        prefix = '.'.join(parts[:i])
        if prefix not in prefix_index:
            prefix_index[prefix] = set()
        prefix_index[prefix].add(obj_id)
```

Add query methods:

```python
def get_node_by_path(self, path: Node_Path) -> Optional[Obj_Id]:
    """Get node ID by exact path match."""
    return self.index_data.nodes_by_path.get(str(path))

def get_edge_by_path(self, path: Edge_Path) -> Optional[Obj_Id]:
    """Get edge ID by exact path match."""
    return self.index_data.edges_by_path.get(str(path))

def get_nodes_by_path_prefix(self, prefix: str) -> Set[Obj_Id]:
    """Get all node IDs matching a path prefix."""
    return self.index_data.nodes_by_path_prefix.get(prefix, set())

def get_edges_by_path_prefix(self, prefix: str) -> Set[Obj_Id]:
    """Get all edge IDs matching a path prefix."""
    return self.index_data.edges_by_path_prefix.get(prefix, set())
```

---

### Part 5: Edit Operations Support

#### File: `mgraph_db/mgraph/actions/MGraph__Edit.py`

Update `new_node` and `new_edge` methods to accept optional path parameters:

```python
def new_node(self, 
             node_type: Type[Schema__MGraph__Node] = None,
             node_path: Node_Path = None,                           # NEW parameter
             **kwargs) -> Schema__MGraph__Node:
    """Create a new node with optional path."""
    # ... existing logic ...
    node.node_path = node_path
    return node

def new_edge(self,
             from_node_id: Obj_Id,
             to_node_id: Obj_Id,
             edge_type: Type[Schema__MGraph__Edge] = None,
             edge_path: Edge_Path = None,                           # NEW parameter
             **kwargs) -> Schema__MGraph__Edge:
    """Create a new edge with optional path."""
    # ... existing logic ...
    edge.edge_path = edge_path
    return edge
```

Add path update methods:

```python
def set_node_path(self, node_id: Obj_Id, node_path: Node_Path) -> bool:
    """Set or update a node's path."""
    node = self.graph.nodes.get(node_id)
    if node:
        node.node_path = node_path
        return True
    return False

def set_edge_path(self, edge_id: Obj_Id, edge_path: Edge_Path) -> bool:
    """Set or update an edge's path."""
    edge = self.graph.edges.get(edge_id)
    if edge:
        edge.edge_path = edge_path
        return True
    return False
```

---

### Part 6: Domain Schema Inheritance

Domain-specific schemas that inherit from the base schemas will automatically gain the path fields. Verify these files don't need modification (they should inherit cleanly):

- `mgraph_db/providers/json/schemas/Schema__MGraph__Json__Node.py`
- `mgraph_db/providers/json/schemas/Schema__MGraph__Json__Edge.py`
- `mgraph_db/providers/time_chain/schemas/Schema__Time_Chain__Node.py`
- `mgraph_db/providers/time_chain/schemas/Schema__Time_Chain__Edge.py`
- All other domain schemas under `mgraph_db/providers/*/schemas/`

---

## Backward Compatibility

### Existing Graphs

When loading a serialized graph that lacks path fields:

1. Type_Safe's default handling sets `node_path = None`, `edge_path = None`, `graph_path = None`
2. No migration required
3. Indexes simply don't populate path-based dictionaries for `None` values

### Existing Code

Code that doesn't use paths continues to work unchanged:

```python
# This still works exactly as before
node = mgraph.edit().new_node(node_type=Domain__Node__Person)
# node.node_path is None - no impact
```

### Serialization

OSBot-Utils Type_Safe serialization will include path fields when present, omit or null when `None`. Verify round-trip works correctly.

---

## Testing Requirements

### Unit Tests for Primitives

#### File: `tests/unit/mgraph/schemas/primitives/test_Safe_Str__Graph__Path.py`

```python
def test_valid_paths():
    """Test valid path patterns."""
    valid = [
        "html.body.div",
        "html.body.div.p[1]",
        "node.path:html.body",
        "config-setting.value",
        "Domain__Node__Person",           # Python type names are valid
        "a",                               # Single char
        "",                                # Empty allowed
        "deeply.nested.path.with.many.levels[1].and[2].indices",
    ]
    for path in valid:
        assert Safe_Str__Graph__Path(path)  # Should not raise

def test_invalid_paths():
    """Test invalid path patterns."""
    invalid = [
        "path with spaces",
        "path/with/slashes",
        "path<with>brackets",
        "path;semicolon",
        "a" * 513,                         # Exceeds max length
    ]
    for path in invalid:
        # Should raise validation error
        with pytest.raises(Exception):
            Safe_Str__Graph__Path(path)

def test_type_safety():
    """Test that path types are distinct."""
    node_path = Node_Path("html.body")
    edge_path = Edge_Path("contains")
    
    # Both valid but different types
    assert isinstance(node_path, Node_Path)
    assert isinstance(edge_path, Edge_Path)
    assert not isinstance(node_path, Edge_Path)
```

### Integration Tests for Schema Changes

#### File: `tests/integration/mgraph/schemas/test_Schema__MGraph__Node__with_path.py`

```python
def test_node_with_path():
    """Test node creation with path."""
    node = Schema__MGraph__Node(
        node_id   = Obj_Id(),
        node_type = Schema__MGraph__Node,
        node_path = Node_Path("html.body.div")
    )
    assert node.node_path == "html.body.div"

def test_node_without_path():
    """Test node creation without path (backward compat)."""
    node = Schema__MGraph__Node(
        node_id   = Obj_Id(),
        node_type = Schema__MGraph__Node
    )
    assert node.node_path is None

def test_node_serialization_roundtrip():
    """Test that path survives serialization."""
    node = Schema__MGraph__Node(
        node_id   = Obj_Id(),
        node_type = Schema__MGraph__Node,
        node_path = Node_Path("test.path[1]")
    )
    json_str = node.json()
    restored = Schema__MGraph__Node.from_json(json_str)
    assert restored.node_path == node.node_path
```

### Integration Tests for Index

#### File: `tests/integration/mgraph/actions/test_MGraph__Index__paths.py`

```python
def test_index_nodes_by_path():
    """Test path-based node indexing."""
    mgraph = MGraph__Graph()
    
    node1 = mgraph.edit().new_node(node_path=Node_Path("html.body"))
    node2 = mgraph.edit().new_node(node_path=Node_Path("html.body.div"))
    node3 = mgraph.edit().new_node(node_path=Node_Path("html.head"))
    node4 = mgraph.edit().new_node()  # No path
    
    index = mgraph.index()
    
    # Exact match
    assert index.get_node_by_path(Node_Path("html.body")) == node1.node_id
    assert index.get_node_by_path(Node_Path("nonexistent")) is None
    
    # Prefix match
    html_nodes = index.get_nodes_by_path_prefix("html")
    assert node1.node_id in html_nodes
    assert node2.node_id in html_nodes
    assert node3.node_id in html_nodes
    assert node4.node_id not in html_nodes  # No path, not indexed
    
    body_nodes = index.get_nodes_by_path_prefix("html.body")
    assert node1.node_id in body_nodes
    assert node2.node_id in body_nodes
    assert node3.node_id not in body_nodes  # html.head, not html.body

def test_index_edges_by_path():
    """Test path-based edge indexing."""
    mgraph = MGraph__Graph()
    
    node1 = mgraph.edit().new_node()
    node2 = mgraph.edit().new_node()
    
    edge = mgraph.edit().new_edge(
        from_node_id = node1.node_id,
        to_node_id   = node2.node_id,
        edge_path    = Edge_Path("relationship.contains")
    )
    
    index = mgraph.index()
    assert index.get_edge_by_path(Edge_Path("relationship.contains")) == edge.edge_id
```

---

## File Summary

### New Files to Create

| File | Description |
|------|-------------|
| `mgraph_db/mgraph/schemas/primitives/Safe_Str__Graph__Path.py` | Base path primitive |
| `mgraph_db/mgraph/schemas/primitives/Graph_Path.py` | Graph path type |
| `mgraph_db/mgraph/schemas/primitives/Node_Path.py` | Node path type |
| `mgraph_db/mgraph/schemas/primitives/Edge_Path.py` | Edge path type |
| `mgraph_db/mgraph/schemas/primitives/__init__.py` | Package init (if needed) |
| `tests/unit/mgraph/schemas/primitives/test_Safe_Str__Graph__Path.py` | Primitive tests |
| `tests/integration/mgraph/actions/test_MGraph__Index__paths.py` | Index tests |

### Files to Modify

| File | Change |
|------|--------|
| `mgraph_db/mgraph/schemas/Schema__MGraph__Graph.py` | Add `graph_path` field |
| `mgraph_db/mgraph/schemas/Schema__MGraph__Node.py` | Add `node_path` field |
| `mgraph_db/mgraph/schemas/Schema__MGraph__Edge.py` | Add `edge_path` field |
| `mgraph_db/mgraph/actions/MGraph__Index__Data.py` | Add path index dictionaries |
| `mgraph_db/mgraph/actions/MGraph__Index.py` | Add path indexing and query methods |
| `mgraph_db/mgraph/actions/MGraph__Edit.py` | Add path params to new_node/new_edge, add set_*_path methods |

---

## Implementation Order

1. **Primitives first** - Create `Safe_Str__Graph__Path`, `Node_Path`, `Edge_Path`, `Graph_Path`
2. **Schema modifications** - Add path fields to core schemas
3. **Run existing tests** - Verify backward compatibility (nothing should break)
4. **Index data structures** - Add path dictionaries to `MGraph__Index__Data`
5. **Index logic** - Add path indexing in `MGraph__Index`
6. **Edit operations** - Update `MGraph__Edit` with path support
7. **New tests** - Add comprehensive tests for path functionality
8. **Integration verification** - Test with existing domain graphs (JSON, HTML providers)

---

## Notes for Implementation

1. **Import ordering**: Follow existing codebase patterns for import ordering and alignment
2. **Type annotations**: Use `Optional[Node_Path]` or `Node_Path = None` consistently with existing patterns
3. **Docstrings**: Add docstrings explaining path purpose and valid formats
4. **Existing tests**: Run full test suite after each modification to catch regressions early
5. **Provider schemas**: Domain schemas inherit from base - verify they don't override in incompatible ways
