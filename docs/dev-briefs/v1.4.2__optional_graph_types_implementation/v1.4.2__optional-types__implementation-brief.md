# MGraph-DB Optional Types Implementation Brief

**version**: v1.42

## Executive Summary

This brief describes the optimization of MGraph-DB's serialization by making type fields optional across core schema objects. When type fields are `None`, a centralized defaults registry (`MGraph__Defaults`) provides opinionated base types. This dramatically reduces JSON payload size for "path-mode" graphs while maintaining full backward compatibility with type-rich "provider-mode" graphs.

**Target reduction: 60-70% smaller JSON for path-mode graphs.**

---

## Motivation

### The Problem

MGraph-DB's Type_Safe foundation automatically resolves `Type[SomeClass]` annotations to actual class references, which serialize as fully-qualified class paths:

```python
# A single node's serialization currently includes:
{
    "node_type": "mgraph_db.mgraph.schemas.Schema__MGraph__Node__Value.Schema__MGraph__Node__Value",
    "node_data": {
        "value_type": "builtins.str",
        "value": "hello"
    }
}
```

For a graph with 1000 nodes, the string `"mgraph_db.mgraph.schemas.Schema__MGraph__Node__Value.Schema__MGraph__Node__Value"` (84 characters) is repeated 1000 times. Add similar repetition for `edge_type`, `graph_type`, and `schema_types`, and the overhead becomes substantial.

### Two Distinct Usage Modes

MGraph-DB serves two distinct usage patterns:

| Mode | Type Fields | Use Case |
|------|-------------|----------|
| **Path-mode** | Not needed | REST API, structural graphs, JSON/HTML parsing |
| **Provider-mode** | Essential | Domain-specific analysis, custom node/edge types, type-safe workflows |

**Path-mode** (introduced in v1.2.19) uses `node_path`, `edge_path`, `graph_path` for structural identification. The Python types are always base MGraph types—storing them is pure overhead.

**Provider-mode** uses custom schema subclasses (e.g., `Schema__MGraph__Json__Node`, `Schema__Time_Chain__Node`) where type information is essential for correct deserialization and behavior.

### Design Decision

Rather than maintaining two separate serialization paths, we make type fields optional with intelligent defaults:

- `None` → Use opinionated defaults from `MGraph__Defaults`
- Explicit type → Use that type (existing provider behavior unchanged)

This achieves:
- Minimal JSON for path-mode graphs
- Zero changes required for existing provider code
- Single code path with fallback logic

---

## Implementation Specification

### Part 1: Defaults Registry

#### File: `mgraph_db/mgraph/MGraph__Defaults.py`

Create a centralized registry of opinionated default types using Type_Safe:

```python
from typing                                                         import Type
from osbot_utils.type_safe.Type_Safe                                import Type_Safe
from mgraph_db.mgraph.schemas.Schema__MGraph__Graph                 import Schema__MGraph__Graph
from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Value           import Schema__MGraph__Node__Value
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge                  import Schema__MGraph__Edge
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge__Data            import Schema__MGraph__Edge__Data
from mgraph_db.mgraph.schemas.Schema__MGraph__Graph__Data           import Schema__MGraph__Graph__Data
from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Value__Data     import Schema__MGraph__Node__Value__Data
from mgraph_db.mgraph.domain.Domain__MGraph__Node                   import Domain__MGraph__Node
from mgraph_db.mgraph.domain.Domain__MGraph__Edge                   import Domain__MGraph__Edge
from mgraph_db.mgraph.models.Model__MGraph__Node                    import Model__MGraph__Node
from mgraph_db.mgraph.models.Model__MGraph__Edge                    import Model__MGraph__Edge


class MGraph__Defaults(Type_Safe):
    """Opinionated defaults for path-mode operation.
    
    These defaults assume the common case: storing values with 
    structural identification via paths, not Python types.
    
    Design decisions:
        - node_type = Schema__MGraph__Node__Value (not base Node)
          Path-mode users store data. Value nodes have value/key/value_type.
        
        - edge_type = Schema__MGraph__Edge
          Clean base type. edge_label and edge_path already optional.
        
        - value_type in node data is NOT made optional
          Keeping "builtins.str" etc. is useful for type coercion on read,
          and Safe_* primitives benefit from explicit type tracking.
    
    Extensibility:
        Providers can subclass to override defaults:
        
        class MGraph__Defaults__Json(MGraph__Defaults):
            node_type: Type[Schema__MGraph__Json__Node__Value]
    """
    
    # Schema types - opinionated for path-mode
    node_type       : Type[Schema__MGraph__Node__Value]         # Value nodes by default
    node_data_type  : Type[Schema__MGraph__Node__Value__Data]
    edge_type       : Type[Schema__MGraph__Edge]
    edge_data_type  : Type[Schema__MGraph__Edge__Data]
    graph_type      : Type[Schema__MGraph__Graph]
    graph_data_type : Type[Schema__MGraph__Graph__Data]
    
    # Domain types
    node_domain_type: Type[Domain__MGraph__Node]
    edge_domain_type: Type[Domain__MGraph__Edge]
    
    # Model types
    node_model_type : Type[Model__MGraph__Node]
    edge_model_type : Type[Model__MGraph__Edge]
```

**Why Type_Safe?** 
- Type_Safe automatically resolves `Type[X]` annotations to actual class references
- Declarative - single glance shows all defaults
- Extensible - providers can subclass and override specific defaults
- Consistent with existing MGraph-DB patterns
- No manual lazy loading, caching, or property decorators needed

**Why `Schema__MGraph__Node__Value` as default `node_type`?** Path-mode users store data. Value nodes provide `value`, `key`, and `value_type` fields—exactly what's needed. Using base `Schema__MGraph__Node` would require users to always specify a more useful subtype.

---

### Part 2: Schema Changes

#### File: `mgraph_db/mgraph/schemas/Schema__MGraph__Graph.py`

Make `graph_type`, `graph_data`, and `schema_types` optional:

```python
from typing                                                         import Dict, Type
from mgraph_db.mgraph.schemas.identifiers.Graph_Path                import Graph_Path
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id    import Obj_Id
from mgraph_db.mgraph.schemas.Schema__MGraph__Types                 import Schema__MGraph__Types
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge                  import Schema__MGraph__Edge
from mgraph_db.mgraph.schemas.Schema__MGraph__Graph__Data           import Schema__MGraph__Graph__Data
from mgraph_db.mgraph.schemas.Schema__MGraph__Node                  import Schema__MGraph__Node
from osbot_utils.type_safe.primitives.domains.identifiers.Edge_Id   import Edge_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Graph_Id  import Graph_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id   import Node_Id
from osbot_utils.type_safe.Type_Safe                                import Type_Safe

class Schema__MGraph__Graph(Type_Safe):
    edges        : Dict[Edge_Id, Schema__MGraph__Edge]
    graph_data   : Schema__MGraph__Graph__Data       = None     # CHANGED: optional
    graph_id     : Graph_Id
    graph_path   : Graph_Path                        = None
    graph_type   : Type['Schema__MGraph__Graph']     = None     # CHANGED: optional
    nodes        : Dict[Node_Id, Schema__MGraph__Node]
    schema_types : Schema__MGraph__Types             = None     # CHANGED: optional

    def __init__(self, **kwargs):
        if kwargs.get('graph_id') is None:
            kwargs['graph_id'] = Graph_Id(Obj_Id())
        super().__init__(**kwargs)
```

#### File: `mgraph_db/mgraph/schemas/Schema__MGraph__Node.py`

Make `node_type` and `node_data` optional:

```python
from typing                                                         import Type
from mgraph_db.mgraph.schemas.identifiers.Node_Path                 import Node_Path
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id    import Obj_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id   import Node_Id
from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Data            import Schema__MGraph__Node__Data
from osbot_utils.type_safe.Type_Safe                                import Type_Safe

class Schema__MGraph__Node(Type_Safe):
    node_data : Schema__MGraph__Node__Data           = None     # CHANGED: optional
    node_id   : Node_Id
    node_path : Node_Path                            = None
    node_type : Type['Schema__MGraph__Node']         = None     # CHANGED: optional

    def __init__(self, **kwargs):
        if kwargs.get('node_id') is None:
            kwargs['node_id'] = Node_Id(Obj_Id())
        super().__init__(**kwargs)
```

#### File: `mgraph_db/mgraph/schemas/Schema__MGraph__Edge.py`

Make `edge_type` and `edge_data` optional:

```python
from typing                                                         import Type
from mgraph_db.mgraph.schemas.identifiers.Edge_Path                 import Edge_Path
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id    import Obj_Id
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge__Data            import Schema__MGraph__Edge__Data
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge__Label           import Schema__MGraph__Edge__Label
from osbot_utils.type_safe.primitives.domains.identifiers.Edge_Id   import Edge_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id   import Node_Id
from osbot_utils.type_safe.Type_Safe                                import Type_Safe


class Schema__MGraph__Edge(Type_Safe):
    edge_id       : Edge_Id
    edge_data     : Schema__MGraph__Edge__Data       = None     # CHANGED: optional
    edge_type     : Type['Schema__MGraph__Edge']     = None     # CHANGED: optional
    edge_label    : Schema__MGraph__Edge__Label      = None
    edge_path     : Edge_Path                        = None
    from_node_id  : Node_Id                          = None
    to_node_id    : Node_Id                          = None

    def __init__(self, **kwargs):
        if kwargs.get('edge_id') is None:
            kwargs['edge_id'] = Edge_Id(Obj_Id())
        super().__init__(**kwargs)
```

#### File: `mgraph_db/mgraph/schemas/Schema__MGraph__Types.py`

Make all type fields optional:

```python
from typing                                                 import Type
from osbot_utils.type_safe.Type_Safe                        import Type_Safe
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge          import Schema__MGraph__Edge
from mgraph_db.mgraph.schemas.Schema__MGraph__Graph__Data   import Schema__MGraph__Graph__Data
from mgraph_db.mgraph.schemas.Schema__MGraph__Node          import Schema__MGraph__Node
from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Data    import Schema__MGraph__Node__Data

class Schema__MGraph__Types(Type_Safe):
    edge_type        : Type[Schema__MGraph__Edge      ] = None  # CHANGED: optional
    graph_data_type  : Type[Schema__MGraph__Graph__Data] = None  # CHANGED: optional
    node_type        : Type[Schema__MGraph__Node      ] = None  # CHANGED: optional
    node_data_type   : Type[Schema__MGraph__Node__Data] = None  # CHANGED: optional
```

#### File: `mgraph_db/mgraph/domain/Domain__MGraph__Types.py`

Make domain type fields optional:

```python
from typing                                       import Type
from mgraph_db.mgraph.domain.Domain__MGraph__Edge import Domain__MGraph__Edge
from mgraph_db.mgraph.domain.Domain__MGraph__Node import Domain__MGraph__Node
from osbot_utils.type_safe.Type_Safe              import Type_Safe

class Domain__MGraph__Types(Type_Safe):
    node_domain_type : Type[Domain__MGraph__Node] = None    # CHANGED: optional
    edge_domain_type : Type[Domain__MGraph__Edge] = None    # CHANGED: optional
```

#### File: `mgraph_db/mgraph/models/Model__MGraph__Types.py`

Make model type fields optional:

```python
from typing                                      import Type
from mgraph_db.mgraph.models.Model__MGraph__Edge import Model__MGraph__Edge
from mgraph_db.mgraph.models.Model__MGraph__Node import Model__MGraph__Node
from osbot_utils.type_safe.Type_Safe             import Type_Safe

class Model__MGraph__Types(Type_Safe):
    node_model_type: Type[Model__MGraph__Node] = None   # CHANGED: optional
    edge_model_type: Type[Model__MGraph__Edge] = None   # CHANGED: optional
```

---

### Part 3: Type Resolution Helper

#### File: `mgraph_db/mgraph/MGraph__Type__Resolver.py`

Create a Type_Safe utility for consistent type resolution that can be injected into consuming classes:

```python
from typing                                     import Type, Optional
from osbot_utils.type_safe.Type_Safe            import Type_Safe
from mgraph_db.mgraph.MGraph__Defaults          import MGraph__Defaults


class MGraph__Type__Resolver(Type_Safe):
    """Resolves optional type fields to actual types using defaults.
    
    Provides a single point for type resolution logic, ensuring 
    consistent behavior across all MGraph-DB components.
    
    The mgraph_defaults field is auto-instantiated by Type_Safe,
    allowing dependency injection and override at multiple levels:
    
    Usage in consuming classes:
        class MGraph__Index(Type_Safe):
            resolver: MGraph__Type__Resolver        # Auto-instantiated
            
            def add_node(self, node):
                node_type = self.resolver.node_type(node.node_type)
    
    Override defaults:
        custom_defaults = MGraph__Defaults__Json()
        resolver = MGraph__Type__Resolver(mgraph_defaults=custom_defaults)
    """
    
    mgraph_defaults: MGraph__Defaults               # Auto-instantiated with base defaults
    
    def node_type(self, type_value: Optional[Type]) -> Type:
        """Resolve node type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.node_type
    
    def node_data_type(self, type_value: Optional[Type]) -> Type:
        """Resolve node data type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.node_data_type
    
    def edge_type(self, type_value: Optional[Type]) -> Type:
        """Resolve edge type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.edge_type
    
    def edge_data_type(self, type_value: Optional[Type]) -> Type:
        """Resolve edge data type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.edge_data_type
    
    def graph_type(self, type_value: Optional[Type]) -> Type:
        """Resolve graph type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.graph_type
    
    def graph_data_type(self, type_value: Optional[Type]) -> Type:
        """Resolve graph data type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.graph_data_type
    
    def node_domain_type(self, type_value: Optional[Type]) -> Type:
        """Resolve node domain type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.node_domain_type
    
    def edge_domain_type(self, type_value: Optional[Type]) -> Type:
        """Resolve edge domain type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.edge_domain_type
    
    def node_model_type(self, type_value: Optional[Type]) -> Type:
        """Resolve node model type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.node_model_type
    
    def edge_model_type(self, type_value: Optional[Type]) -> Type:
        """Resolve edge model type, using default if None."""
        return type_value if type_value is not None else self.mgraph_defaults.edge_model_type
```

**Why Type_Safe with `mgraph_defaults` field?**
- Type_Safe automatically instantiates `MGraph__Defaults()` when not provided
- Enables dependency injection - pass custom defaults via constructor
- Overridable at multiple levels (defaults class, resolver instance, consuming class)
- Testable - can inject mock defaults for testing
- Consistent with existing MGraph-DB patterns
- No singletons or module-level state

**Provider Override Example:**

```python
# Custom defaults for JSON provider
class MGraph__Defaults__Json(MGraph__Defaults):
    node_type      : Type[Schema__MGraph__Json__Node__Value]
    node_data_type : Type[Schema__MGraph__Json__Node__Value__Data]

# Create resolver with custom defaults
resolver = MGraph__Type__Resolver(mgraph_defaults=MGraph__Defaults__Json())

# Or override at the consuming class level
class MGraph__Json__Index(MGraph__Index):
    def __init__(self, **kwargs):
        if 'resolver' not in kwargs:
            kwargs['resolver'] = MGraph__Type__Resolver(mgraph_defaults=MGraph__Defaults__Json())
        super().__init__(**kwargs)
```

---

### Part 4: Model Layer Changes

#### File: `mgraph_db/mgraph/models/Model__MGraph__Graph.py`

Add resolver as a field and update `new_node` and `new_edge` to use type resolution:

```python
# Add import at top
from mgraph_db.mgraph.MGraph__Type__Resolver import MGraph__Type__Resolver

class Model__MGraph__Graph(Type_Safe):
    data       : Schema__MGraph__Graph
    model_types: Model__MGraph__Types
    resolver   : MGraph__Type__Resolver                         # NEW: auto-instantiated

# Modify new_node method:
def new_node(self, **kwargs):
    if 'node_type' in kwargs and 'node_data' in kwargs:
        node_type = kwargs.get('node_type')
        node_data = kwargs.get('node_data')
        del kwargs['node_type']
        del kwargs['node_data']
        node = node_type(node_data=node_data, **kwargs)
        return self.add_node(node)

    if 'node_type' in kwargs:
        node_type = kwargs.get('node_type')
        node_type__annotations = dict(type_safe_cache.get_class_annotations(node_type))
        node_data_type = node_type__annotations.get('node_data')
    elif self.data.schema_types is not None:                    # CHANGED: check for None
        node_type = self.data.schema_types.node_type
        node_data_type = self.data.schema_types.node_data_type
        # Still need to resolve if schema_types exists but fields are None
        node_type = self.resolver.node_type(node_type)          # NEW
        node_data_type = self.resolver.node_data_type(node_data_type)  # NEW
    else:                                                       # NEW: fallback to defaults
        node_type = self.resolver.node_type(None)
        node_data_type = self.resolver.node_data_type(None)
    
    # ... rest of method unchanged ...
```

Update `new_edge` similarly:

```python
def new_edge(self, **kwargs) -> Model__MGraph__Edge:
    if 'edge_type' not in kwargs:
        if self.data.schema_types is not None:                  # CHANGED
            edge_type = self.data.schema_types.edge_type
            edge_type = self.resolver.edge_type(edge_type)      # NEW
        else:                                                   # NEW
            edge_type = self.resolver.edge_type(None)
        kwargs['edge_type'] = edge_type
    
    edge = kwargs.get('edge_type')(**kwargs)
    return self.add_edge(edge)
```

Update model type accessors:

```python
def edges(self):
    model_type = self.resolver.edge_model_type(
        self.model_types.edge_model_type if self.model_types else None
    )
    return [model_type(data=data) for data in self.data.edges.values()]

def nodes(self) -> List[Model__MGraph__Node]:
    model_type = self.resolver.node_model_type(
        self.model_types.node_model_type if self.model_types else None
    )
    return [model_type(data=node) for node in self.data.nodes.values()]
```

---

### Part 5: Index Layer Changes

#### File: `mgraph_db/mgraph/actions/MGraph__Index.py`

Add resolver as a field and update all type-dependent operations:

```python
# Add import at top
from mgraph_db.mgraph.MGraph__Type__Resolver import MGraph__Type__Resolver

class MGraph__Index(Type_Safe):
    index_data  : Schema__MGraph__Index__Data
    values_index: MGraph__Index__Values
    resolver    : MGraph__Type__Resolver                        # NEW: auto-instantiated

# Update add_node:
def add_node(self, node: Schema__MGraph__Node) -> None:
    node_id = node.node_id
    node_type = self.resolver.node_type(node.node_type)         # CHANGED
    node_type_name = node_type.__name__

    self.index_data.nodes_types[node_id] = node_type_name
    # ... rest unchanged ...

# Update add_edge:
def add_edge(self, edge: Schema__MGraph__Edge) -> None:
    edge_id = edge.edge_id
    from_node_id = edge.from_node_id
    to_node_id = edge.to_node_id
    edge_type = self.resolver.edge_type(edge.edge_type)         # CHANGED
    edge_type_name = edge_type.__name__
    
    # ... rest unchanged ...

# Update remove_node:
def remove_node(self, node: Schema__MGraph__Node) -> None:
    node_id = node.node_id
    # ... existing edge removal code ...
    
    node_type = self.resolver.node_type(node.node_type)         # CHANGED
    node_type_name = node_type.__name__
    
    if node_type_name in self.index_data.nodes_by_type:
        self.index_data.nodes_by_type[node_type_name].discard(node_id)
        # ... rest unchanged ...

# Update remove_edge:
def remove_edge(self, edge: Schema__MGraph__Edge) -> None:
    edge_id = edge.edge_id
    # ... existing code ...
    
    edge_type = self.resolver.edge_type(edge.edge_type)         # CHANGED
    edge_type_name = edge_type.__name__
    
    if edge_type_name in self.index_data.edges_by_type:
        # ... rest unchanged ...
```

---

### Part 6: Domain Layer Changes

#### File: `mgraph_db/mgraph/domain/Domain__MGraph__Graph.py`

Add resolver as a field and update to use type resolution:

```python
# Add import at top
from mgraph_db.mgraph.MGraph__Type__Resolver import MGraph__Type__Resolver

class Domain__MGraph__Graph(Type_Safe):
    domain_types : Domain__MGraph__Types
    model        : Model__MGraph__Graph
    graph_type   : Type['Domain__MGraph__Graph']
    resolver     : MGraph__Type__Resolver                       # NEW: auto-instantiated

# Update mgraph_edge method:
def mgraph_edge(self, edge: Model__MGraph__Edge) -> Domain__MGraph__Edge:
    edge_domain_type = self.resolver.edge_domain_type(
        self.domain_types.edge_domain_type if self.domain_types else None
    )
    return edge_domain_type(edge=edge, graph=self.model)

# Update mgraph_node method:
def mgraph_node(self, node: Model__MGraph__Node) -> Domain__MGraph__Node:
    node_domain_type = self.resolver.node_domain_type(
        self.domain_types.node_domain_type if self.domain_types else None
    )
    return node_domain_type(node=node, graph=self.model)
```

---

### Part 7: Export Layer Changes

#### File: `mgraph_db/mgraph/actions/exporters/MGraph__Export__Base.py`

Add resolver as a field and update to use type resolution:

```python
# Add import at top
from mgraph_db.mgraph.MGraph__Type__Resolver import MGraph__Type__Resolver

class MGraph__Export__Base(Type_Safe):
    graph   : Domain__MGraph__Graph
    context : Model__MGraph__Export__Context
    resolver: MGraph__Type__Resolver                            # NEW: auto-instantiated

# Update create_node_data:
def create_node_data(self, node) -> Dict[str, Any]:
    node_type = self.resolver.node_type(node.node.data.node_type)   # CHANGED
    return {
        'id'  : str(node.node_id),
        'type': node_type.__name__
    }

# Update create_edge_data:
def create_edge_data(self, edge) -> Dict[str, Any]:
    edge_type = self.resolver.edge_type(edge.edge.data.edge_type)   # CHANGED
    return {
        'id'    : str(edge.edge_id),
        'source': str(edge.from_node_id()),
        'target': str(edge.to_node_id()),
        'type'  : edge_type.__name__
    }
```

#### File: `mgraph_db/mgraph/actions/exporters/dot/render/MGraph__Export__Dot__Node__Renderer.py`

Add resolver as a field and update type access:

```python
# Add import at top
from mgraph_db.mgraph.MGraph__Type__Resolver import MGraph__Type__Resolver

class MGraph__Export__Dot__Node__Renderer(MGraph__Export__Dot__Base):
    # Note: resolver may be inherited from base or added here
    resolver: MGraph__Type__Resolver                            # NEW: auto-instantiated

# Update create_node_shape_attributes:
def create_node_shape_attributes(self, node: Domain__MGraph__Node) -> List[str]:
    attrs = {}
    styles = set()
    node_type = self.resolver.node_type(node.node.data.node_type)   # CHANGED
    node_id = node.node_id
    
    # ... rest uses node_type variable unchanged ...
```

Similar updates needed in:
- `MGraph__Export__Dot__Base.py` - add resolver field
- `MGraph__Export__Dot__Edge__Renderer.py` - use `self.resolver.edge_type()`
- `MGraph__Export__Cytoscape.py` - add resolver field and use it

---

### Part 8: MGraph Entry Point Changes

#### File: `mgraph_db/mgraph/MGraph.py`

The `MGraph` class references type classes. Ensure they handle None:

```python
from typing                                         import Type
from mgraph_db.mgraph.actions.MGraph__Builder       import MGraph__Builder
from mgraph_db.mgraph.actions.MGraph__Values        import MGraph__Values
from mgraph_db.mgraph.actions.MGraph__Export        import MGraph__Export
from mgraph_db.mgraph.actions.MGraph__Screenshot    import MGraph__Screenshot
from mgraph_db.mgraph.domain.Domain__MGraph__Graph  import Domain__MGraph__Graph
from mgraph_db.mgraph.actions.MGraph__Data          import MGraph__Data
from mgraph_db.mgraph.actions.MGraph__Edit          import MGraph__Edit
from mgraph_db.mgraph.actions.MGraph__Index         import MGraph__Index
from mgraph_db.query.MGraph__Query                  import MGraph__Query
from osbot_utils.decorators.methods.cache_on_self   import cache_on_self
from osbot_utils.type_safe.Type_Safe                import Type_Safe

class MGraph(Type_Safe):
    graph           : Domain__MGraph__Graph
    query_class     : Type[MGraph__Query     ] = None               # CHANGED: optional
    edit_class      : Type[MGraph__Edit      ] = None               # CHANGED: optional
    screenshot_class: Type[MGraph__Screenshot] = None               # CHANGED: optional

    @cache_on_self
    def edit(self) -> MGraph__Edit:
        edit_class = self.edit_class or MGraph__Edit                # CHANGED
        return edit_class(graph=self.graph)

    def query(self) -> MGraph__Query:
        query_class = self.query_class or MGraph__Query             # CHANGED
        mgraph_data = self.data()
        mgraph_index = self.index()
        mgraph_query = query_class(mgraph_data=mgraph_data, mgraph_index=mgraph_index).setup()
        return mgraph_query

    def screenshot(self, **kwargs):
        screenshot_class = self.screenshot_class or MGraph__Screenshot  # CHANGED
        return screenshot_class(**kwargs, graph=self.graph)
    
    # ... other methods unchanged ...
```

---

## Serialization Impact

### Before (path-mode graph with 1 value node):

```json
{
  "graph": {
    "domain_types": {
      "node_domain_type": "mgraph_db.mgraph.domain.Domain__MGraph__Node.Domain__MGraph__Node",
      "edge_domain_type": "mgraph_db.mgraph.domain.Domain__MGraph__Edge.Domain__MGraph__Edge"
    },
    "model": {
      "data": {
        "graph_id": "c0787747",
        "graph_type": "mgraph_db.mgraph.schemas.Schema__MGraph__Graph.Schema__MGraph__Graph",
        "graph_path": null,
        "graph_data": {},
        "schema_types": {
          "edge_type": "mgraph_db.mgraph.schemas.Schema__MGraph__Edge.Schema__MGraph__Edge",
          "graph_data_type": "mgraph_db.mgraph.schemas.Schema__MGraph__Graph__Data.Schema__MGraph__Graph__Data",
          "node_type": "mgraph_db.mgraph.schemas.Schema__MGraph__Node.Schema__MGraph__Node",
          "node_data_type": "mgraph_db.mgraph.schemas.Schema__MGraph__Node__Data.Schema__MGraph__Node__Data"
        },
        "nodes": {
          "adf69958": {
            "node_id": "adf69958",
            "node_type": "mgraph_db.mgraph.schemas.Schema__MGraph__Node__Value.Schema__MGraph__Node__Value",
            "node_path": null,
            "node_data": {
              "value": "this is a new value",
              "value_type": "builtins.str",
              "key": ""
            }
          }
        },
        "edges": {}
      },
      "model_types": {
        "node_model_type": "mgraph_db.mgraph.models.Model__MGraph__Node.Model__MGraph__Node",
        "edge_model_type": "mgraph_db.mgraph.models.Model__MGraph__Edge.Model__MGraph__Edge"
      }
    },
    "graph_type": "mgraph_db.mgraph.domain.Domain__MGraph__Graph.Domain__MGraph__Graph"
  },
  "query_class": "mgraph_db.query.MGraph__Query.MGraph__Query",
  "edit_class": "mgraph_db.mgraph.actions.MGraph__Edit.MGraph__Edit",
  "screenshot_class": "mgraph_db.mgraph.actions.MGraph__Screenshot.MGraph__Screenshot"
}
```

### After (path-mode, None fields omitted by json__compress):

```json
{
  "graph": {
    "model": {
      "data": {
        "graph_id": "c0787747",
        "nodes": {
          "adf69958": {
            "node_id": "adf69958",
            "node_data": {
              "value": "this is a new value",
              "value_type": "builtins.str",
              "key": ""
            }
          }
        },
        "edges": {}
      }
    }
  }
}
```

**Reduction: ~75% smaller**

---

## Backward Compatibility

### Loading Existing Graphs

Existing serialized graphs contain explicit type values:

```json
{
  "node_type": "mgraph_db.mgraph.schemas.Schema__MGraph__Node__Value.Schema__MGraph__Node__Value"
}
```

These load unchanged. The type resolution only applies when fields are `None`.

### Provider Code

Provider schemas (JSON, Time Series, etc.) that extend base schemas continue to work:

```python
class Schema__MGraph__Json__Node(Schema__MGraph__Node):
    node_data : Schema__MGraph__Json__Node__Data    # Explicit - not None
```

When a provider explicitly sets types, those types are used. The defaults only kick in for `None` values.

### Index Behavior

The index stores type names as strings. With resolution:
- Path-mode nodes with `node_type=None` → indexed as `"Schema__MGraph__Node__Value"`
- Provider nodes with explicit types → indexed as their specific type name

This is consistent and queryable.

---

## Testing Requirements

### Unit Tests for Defaults Registry

#### File: `tests/unit/mgraph/test_MGraph__Defaults.py`

```python
def test_defaults_are_correct_types():
    """Verify defaults return expected types."""
    from mgraph_db.mgraph.MGraph__Defaults import MGraph__Defaults
    from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Value import Schema__MGraph__Node__Value
    from mgraph_db.mgraph.schemas.Schema__MGraph__Edge import Schema__MGraph__Edge
    
    defaults = MGraph__Defaults()
    
    assert defaults.node_type == Schema__MGraph__Node__Value
    assert defaults.edge_type == Schema__MGraph__Edge

def test_defaults_type_safe_instantiation():
    """Verify Type_Safe auto-resolves Type[X] annotations."""
    from mgraph_db.mgraph.MGraph__Defaults import MGraph__Defaults
    
    defaults = MGraph__Defaults()
    
    # Should be actual class references, not strings
    assert isinstance(defaults.node_type, type)
    assert isinstance(defaults.edge_type, type)

def test_defaults_can_be_subclassed():
    """Verify providers can override defaults."""
    from mgraph_db.mgraph.MGraph__Defaults import MGraph__Defaults
    from mgraph_db.mgraph.schemas.Schema__MGraph__Node import Schema__MGraph__Node
    
    class Custom__Defaults(MGraph__Defaults):
        node_type: type = Schema__MGraph__Node      # Override to base node
    
    custom = Custom__Defaults()
    assert custom.node_type == Schema__MGraph__Node
```

### Unit Tests for Type Resolver

#### File: `tests/unit/mgraph/test_MGraph__Type__Resolver.py`

```python
def test_resolver_returns_value_when_not_none():
    """Explicit types should pass through unchanged."""
    from mgraph_db.mgraph.MGraph__Type__Resolver import MGraph__Type__Resolver
    from mgraph_db.mgraph.schemas.Schema__MGraph__Node import Schema__MGraph__Node
    
    resolver = MGraph__Type__Resolver()
    result = resolver.node_type(Schema__MGraph__Node)
    
    assert result == Schema__MGraph__Node

def test_resolver_returns_default_when_none():
    """None should resolve to default."""
    from mgraph_db.mgraph.MGraph__Type__Resolver import MGraph__Type__Resolver
    from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Value import Schema__MGraph__Node__Value
    
    resolver = MGraph__Type__Resolver()
    result = resolver.node_type(None)
    
    assert result == Schema__MGraph__Node__Value

def test_resolver_uses_injected_defaults():
    """Custom defaults should be used when injected."""
    from mgraph_db.mgraph.MGraph__Type__Resolver import MGraph__Type__Resolver
    from mgraph_db.mgraph.MGraph__Defaults import MGraph__Defaults
    from mgraph_db.mgraph.schemas.Schema__MGraph__Node import Schema__MGraph__Node
    
    class Custom__Defaults(MGraph__Defaults):
        node_type: type = Schema__MGraph__Node
    
    resolver = MGraph__Type__Resolver(mgraph_defaults=Custom__Defaults())
    result = resolver.node_type(None)
    
    assert result == Schema__MGraph__Node

def test_resolver_auto_instantiates_defaults():
    """Resolver should auto-create MGraph__Defaults if not provided."""
    from mgraph_db.mgraph.MGraph__Type__Resolver import MGraph__Type__Resolver
    from mgraph_db.mgraph.MGraph__Defaults import MGraph__Defaults
    
    resolver = MGraph__Type__Resolver()
    
    assert resolver.mgraph_defaults is not None
    assert isinstance(resolver.mgraph_defaults, MGraph__Defaults)
```

### Integration Tests for Path-Mode Graphs

#### File: `tests/integration/mgraph/test_MGraph__path_mode.py`

```python
def test_path_mode_graph_creation():
    """Create graph without explicit types."""
    from mgraph_db.mgraph.MGraph import MGraph
    from mgraph_db.mgraph.schemas.identifiers.Node_Path import Node_Path
    
    with MGraph() as g:
        node = g.edit().new_value("hello", node_path=Node_Path("root"))
        
        # Should work without types
        assert node.node_data.value == "hello"
        assert node.node_path == "root"

def test_path_mode_serialization_minimal():
    """Verify path-mode graphs serialize without type overhead."""
    from mgraph_db.mgraph.MGraph import MGraph
    
    with MGraph() as g:
        g.edit().new_value("test")
        
        json_data = g.graph.model.data.json__compress()
        
        # These should not be present (None = omitted)
        assert 'graph_type' not in json_data or json_data['graph_type'] is None
        assert 'schema_types' not in json_data or json_data['schema_types'] is None

def test_path_mode_roundtrip():
    """Verify path-mode graphs survive serialization/deserialization."""
    from mgraph_db.mgraph.MGraph import MGraph
    from mgraph_db.mgraph.schemas.Schema__MGraph__Graph import Schema__MGraph__Graph
    
    # Create minimal graph
    with MGraph() as g:
        g.edit().new_value("test value")
        json_str = g.graph.model.data.json()
    
    # Reload
    restored = Schema__MGraph__Graph.from_json(json_str)
    
    # Should have one node with correct value
    assert len(restored.nodes) == 1
    node = list(restored.nodes.values())[0]
    assert node.node_data.value == "test value"
```

### Integration Tests for Provider Compatibility

#### File: `tests/integration/mgraph/test_MGraph__provider_mode.py`

```python
def test_provider_mode_still_works():
    """Verify explicit types still work for providers."""
    from mgraph_db.providers.json.MGraph__Json import MGraph__Json
    
    # Provider usage should be unchanged
    json_data = {"key": "value"}
    mgraph = MGraph__Json()
    mgraph.load(json_data)
    
    # Types should be provider-specific, not defaults
    for node in mgraph.data().nodes():
        assert "Json" in node.node_type.__name__
```

---

## File Summary

### New Files to Create

| File | Description |
|------|-------------|
| `mgraph_db/mgraph/MGraph__Defaults.py` | Central defaults registry (Type_Safe class) |
| `mgraph_db/mgraph/MGraph__Type__Resolver.py` | Type resolution utility (Type_Safe class with injected defaults) |
| `tests/unit/mgraph/test_MGraph__Defaults.py` | Defaults tests |
| `tests/unit/mgraph/test_MGraph__Type__Resolver.py` | Resolver tests |
| `tests/integration/mgraph/test_MGraph__path_mode.py` | Path-mode integration tests |
| `tests/integration/mgraph/test_MGraph__provider_mode.py` | Provider compatibility tests |

### Files to Modify

| File | Change |
|------|--------|
| `mgraph_db/mgraph/schemas/Schema__MGraph__Graph.py` | Make `graph_type`, `graph_data`, `schema_types` optional |
| `mgraph_db/mgraph/schemas/Schema__MGraph__Node.py` | Make `node_type`, `node_data` optional |
| `mgraph_db/mgraph/schemas/Schema__MGraph__Edge.py` | Make `edge_type`, `edge_data` optional |
| `mgraph_db/mgraph/schemas/Schema__MGraph__Types.py` | Make all type fields optional |
| `mgraph_db/mgraph/domain/Domain__MGraph__Types.py` | Make domain type fields optional |
| `mgraph_db/mgraph/domain/Domain__MGraph__Graph.py` | Add `resolver` field, use resolved types for domain objects |
| `mgraph_db/mgraph/models/Model__MGraph__Types.py` | Make model type fields optional |
| `mgraph_db/mgraph/models/Model__MGraph__Graph.py` | Add `resolver` field, add type resolution in `new_node`, `new_edge` |
| `mgraph_db/mgraph/actions/MGraph__Index.py` | Add `resolver` field, use resolved types in indexing |
| `mgraph_db/mgraph/actions/exporters/MGraph__Export__Base.py` | Add `resolver` field, use resolved types |
| `mgraph_db/mgraph/actions/exporters/dot/render/MGraph__Export__Dot__Base.py` | Add `resolver` field |
| `mgraph_db/mgraph/actions/exporters/dot/render/MGraph__Export__Dot__Node__Renderer.py` | Use inherited `resolver` for type resolution |
| `mgraph_db/mgraph/actions/exporters/dot/render/MGraph__Export__Dot__Edge__Renderer.py` | Use inherited `resolver` for type resolution |
| `mgraph_db/mgraph/MGraph.py` | Make class reference fields optional |

---

## Implementation Order

1. **Create `MGraph__Defaults.py`** - Type_Safe class with default type annotations
2. **Create `MGraph__Type__Resolver.py`** - Type_Safe class with `mgraph_defaults` field
3. **Update schemas** - Make type/data fields optional (`= None`)
4. **Run existing tests** - Many will fail (expected)
5. **Fix `Model__MGraph__Graph`** - Add `resolver` field, update `new_node`/`new_edge`
6. **Fix `MGraph__Index`** - Add `resolver` field, use resolved types
7. **Fix `Domain__MGraph__Graph`** - Add `resolver` field, handle optional `domain_types`
8. **Fix exporters** - Add `resolver` field to base class, use resolved types
9. **Fix `MGraph.py`** - Handle optional class references
10. **Add new tests** - Defaults, resolver, path-mode, provider-mode
11. **Verify serialization** - Confirm None fields omit correctly with `json__compress`
12. **Test with existing providers** - JSON, Time Series, HTML should work unchanged

---

## Notes for Implementation

### Import Ordering
Follow existing codebase patterns for import ordering and alignment.

### Type_Safe Pattern
Both `MGraph__Defaults` and `MGraph__Type__Resolver` use Type_Safe, which provides:
- Automatic instantiation of class fields when not provided
- Type resolution for `Type[X]` annotations
- Consistent behavior with the rest of MGraph-DB

### Resolver Injection Pattern
Always add resolver as a field to classes that need type resolution:
```python
class SomeClass(Type_Safe):
    resolver: MGraph__Type__Resolver        # Auto-instantiated with defaults

    def some_method(self):
        node_type = self.resolver.node_type(node.node_type)
```

This enables:
- Dependency injection via constructor
- Override at any level (defaults, resolver, consuming class)
- Testability with mock defaults

### Provider Override Pattern
Providers can customize defaults at multiple levels:

```python
# Level 1: Custom defaults class
class MGraph__Defaults__Json(MGraph__Defaults):
    node_type: Type[Schema__MGraph__Json__Node__Value]

# Level 2: Inject into resolver
resolver = MGraph__Type__Resolver(mgraph_defaults=MGraph__Defaults__Json())

# Level 3: Inject resolver into consuming class
index = MGraph__Index(resolver=resolver)

# Level 4: Subclass consuming class
class MGraph__Json__Index(MGraph__Index):
    def __init__(self, **kwargs):
        if 'resolver' not in kwargs:
            kwargs['resolver'] = MGraph__Type__Resolver(mgraph_defaults=MGraph__Defaults__Json())
        super().__init__(**kwargs)
```

### value_type Preservation
The `value_type` field in `Schema__MGraph__Node__Value__Data` remains required (not optional). This preserves type information for value coercion and supports Safe_* primitive types. The overhead of `"builtins.str"` is acceptable given the utility.

### Provider Testing
After implementation, run the full test suite for all providers to ensure they continue to function correctly with explicit types.

### Serialization Verification
Verify that `json__compress()` correctly omits `None` fields. If not, additional serialization logic may be needed to strip None values.